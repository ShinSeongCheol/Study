# 정렬
## 기준에 따라 데이터를 정렬
정렬 : 데이터를 특정한 기준에 따라 순서대로 나열

## 선택 정렬
- 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복
- 시간복잡도는 O(N²)
- [selectionSort.java]

## 삽입정렬
- 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 알고리즘
- 데이터가 거의 정렬 되어 있을때 효율적
- 삽입 정렬은 특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 **삽입 정렬**이라고 한다.
- 삽입정렬의 시간 복잡도는 O(N²)이며 최선일 경우는 O(N)이다.
- [InsertionSort.java]

## 퀵정렬
- 가장 많이 사용되는 알고리즘
- 기준 데이터를 설정하고 그 기분보다 큰 데이터와 작은 데이터의 위치를 바꾸는 알고리즘
- 퀵 정렬의 평균 시간 복잡도는 O(NlogN), 최악(데이터가 정렬되어 있을때)일 때는 O(N²)이다.
- [quickSort.java]

## 계수 정렬
- 특정한 조건이 부합할때만 사용가능하지만 매우 빠른 정렬 알고리즘
- 데이터의 개수 N, 데이터중 최대값
- 계수정렬은 최악의 경우에도 O(N + K)를 보장한다.
- 시간복잡도는 O(N+K)
- 공간 복잡도 계수 정렬은 때에 따라서 심각한 비효율을 초래할 수 있다.
- 공간복잡도는 O(N+K)다
- [countingSort.java]

## 위에서 아래로
이 문제는 정렬을 할 수있는가를 묻는 문제였다. 처음에 문제를 풀때 Arrays.sort() 메서드를 사용해서 문제를 해결하려고 했는데 거꾸로 출력을 하는 부분을 좀 색다르게 하고 싶어서 comporator인터페이스를 사용하고 싶었다. 그 과정에서 comporable과 comporator를 알게 되었고 어떻게 하면 구현할 수 있는지와 익명클래스를 작성하는 방법을 알 수 있게 되었다. 하지만 
이 인터페이스를 사용하려면 원시값말고 다른 클래스를 사용해야 해서 Arrays.sort()를 하고 거꾸로 출력하도록 만들었다. 다른 방법으로는 Integer 클래스 형으로 배열을 만들어서 Arrays.sort() 메서드의 인수로 배열과 comprator.reverseOrder()를 사용해서 내림차 정렬을 했다.

## 성적이 낮은 순서로 학생 출력하기
이 문제는 정렬하는 문제였는데 입력으로 이름과 점수가 들어왔다. 문제를 해결하기 위해 어떻게 해야할지 고민하다가 클래스 하나 생성하고 멤버변수로 이름과 점수를 저장하도록 만드는 방법이 좋을거 같아 student 클래스를 생성했다 그리고 Comparator 인터페이스를 사용해서 객체 정렬을 했다. Comparble 인터페이스와 Comparator 인터페이스를 사용할 수 있었는데 나는 Comparator 클래스를 익명클래스로 구현하는 것이 좋을 것같다고 느껴서 main메서드 안에 익명클래스를 구현하고 Arrays.sort()메서드의 두번째 인수로 비교할수 있도록 구현했다. Compable과 Comparator 인터페이스 사용방법을 알 수 있었던 좋은 문제였다. Comparator 메서드를 구현할때 언더 플로우와 오버플로우를 조심해야한다!

## 두 배열의 원소 교체
이 문제는 두개의 배열중 원하는 값을 교체하는 문제였다 해결하기 위해서 배열들을 정렬했는데 나중에 편하게 하기 위해서 하나는 오름차순 정렬 다른 하나는 내림차순 정렬을 사용해 큰값이 먼저오게 만들었다. 내림차순 정렬을 하기 위해서 Collections.reverseOrder() 메서드를 사용했다. 여기서 빠뜨린 부분이 하나 있었는데 첫번재 배열과 두번째 배열의 숫자 크기비교를 하지않아서 첫번째 배열의 숫자가 두번째 배열의 숫자가 작지 않도록 구현했다. 무엇이 필요하진 더 찾는 능력을 길러야할거 같다. 문제를 거의 풀었는데 저거 하나 때문에 완벽하게 풀지 못했던거 같다.