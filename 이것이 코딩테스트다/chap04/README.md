# 구현
- 코딩 테스트에서 구현이란 '머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정'
- 완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행
## 예제 4-1 상하좌우
- [chap04_01.java]
- 처음 이 문제를 풀었을 때 어떻게 풀어야하는지 고민했다. 2차원 배열을 사용해서 문제를 풀수 있을까 생각을 했고 메모리를 많이 잡지 않을까 했다.
- 아무리 생각해도 효율적으로 문제를 풀 방법을 떠오르지 못했다. 그래서 풀이를 살짝 보면서 문제를 풀었다. 파이썬 코드를 보면서 자바 코드로 변환을 했는데 이 과정에서 char 자료형을 써서 할 수 있는걸 String을 사용해서 문제를 푼것을 나중에 알게 되었다. char 자료형을 많이 사용해 보지 않아서 그랬던것 같다. 논리적 사고력을 기를 수 있도록 많은 문제를 풀어보고 글로 작성해봐야겠다.
## 예제 4-2 시각
- 이 문제는 완전 탐색 유형으로 모든 경우의 수를 확인하면 되는 문제였다. 그런데 자바로 구현을 해보니 삼중 포문안에 조건문으로
``` 
if (h % 10 == 3 || m % 10 == 3 || m / 10 == 3 || s % 10 == 3 || s / 10 == 3)
``` 
- 을 넣으니깐 제대로 동작이 되지 않았다. 개인적인 생각으로는 m % 10과 m / 10이 한줄에 있어서 컴파일러의 영향으로 한줄에 2개의 연산이 되버린게 아닌가 싶다.
- 그래서 그 문제를 해결하기 위해 나누기 연산을 먼저 하면 정상적으로 작동이 되는것을 확인 할 수 있었다.
- 이 문제에서 배울수 있었던 것은 자바의 연산자 우선순위와 메서드 추출을 잘해야겠다는 생각이 든다.
## 예제 4-3 왕실의 나이트
- [chap04_03.java]
- 이 문제는 앞에서 풀었던 상하좌우 문제와 비슷했다. 이 문제에서 헷갈렸던 부분은 처음에 입력값으로 2개의 문자가 붙어서 오는 경우였는데 split() 메서드를 통해 String 배열을 반환하려고 했다.
- 하지만 split()메서드는 붙어있는 문자는 떨어뜨릴 수 없었다.
- 그래서 문자 하나하나를 char로 취급해 처리하기로 하고 처음 위치를 지정하기 위해 'a'와 '1'을 빼고 1을 더해서 a1이 들어왔을 경우 1,1의 위치를 나타내도록 했다.
- 그리고 나이트가 이동할 수 있는 모든 경우의 수를 만들어서 탐색하도록 만들었다.
## 예제 4-4 게임 개발
- [chap04_04.java]
- 게임 개발 문제는 시뮬레이션 유형으로 아직 익숙하지 않아서 어려웠다. 
- 여기서 신기하고 흥미로웠던 점은 내가 간곳을 표시하는 배열과 맵을 표시하는 배열 2개를 이용하여 문제를 풀었다는 점이다. 
- 시뮬레이션 문제 유형은 문제를 이해하고 요구하는 내용을 성실하게 구현하면 풀 수 있을거 같다.
- 아직은 익숙하지 않고 프로그래밍 언어로 구현하는 것이 어렵게 느껴진다.