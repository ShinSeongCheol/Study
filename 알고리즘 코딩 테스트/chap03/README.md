# 자료 구조
- 자료 구조는 데이터를 효율적으로 저장, 접근, 수정하기 위한 그릇

## 배열과 리스트
### 배열
- 배열의 특징
  - 인덱스를 사용하여 값에 바로 접근 가능
  - 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요
  - 배열의 크기는 선언할 때 지정할 수 있으며, 한 번 선언하면 크기를 늘리거나 줄일 수 없다.
  - 구조가 간단하므로 코딩테스트에서 많이 사용

### 리스트
- 리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
- 리스트의 특징
  - 인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야한다. 값에 접근하는 속도가 느리다.
  - 선언할 때 크기를 별도로 지정하지 않아도 된다. 리스트의 크기는 정해져 있지 않으며, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.
  - 포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡하다.

### 숫자의 합 구하기
이 문제는 입력받은 N개의 숫자 만큼 숫자를 다 더한 값을 출력하는 문제였다. 처음에 Scanner의 nextInt() 메서드로 숫자를 다 받아오려 했지만 2번째 줄에 있는 숫자는 붙어있어서 nextInt() 메서드가 여러번 실행이 안됬다는걸 알게 되었다. 그래서 전체 줄을 읽어들여 String.charAt() 메서드로 값을 불러온 다음 숫자 '0'을 빼서 다 더한 값을 출력하게 만들었다. nextInt() 메서드가 한 문자만 가져온다고 생각하지 말아야겠다.
[chap03_01.java]

### 평균 구하기
이 문제는 입력값으로 주어진 배열값중에서 최댓값을 구하고 최댓값을 이용해 새로운 연산을 하는 문제였다. 나는 최댓값을 구하기 위해 Integer.MIN_VALUE 값을 이용해서 최소값을 할당하고 배열을 순환하면서 최댓값을 구하고 다시 한번 배열을 순환하면서 평균 값을 구하는 연산을 하였다. 그런데 책에서는 최댓값과 점수 합을 같이 구하고  평균값을 구하는 방법을 하였다. 이렇게 하면 반복문 하나를 줄일 수 있어서 더 좋은 거 같다. 알고리즘을 최적화 하는 방법을 생각하면서 구현하는 능력을 길러야한다고 느낄 수 있는 문제였다.
[chap03_02.java]

## 구간 합
- 구간 합은 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘

### 구간 합의 핵심 이론
- 구간 합 알고리즘을 활용하려면 먼저 합 배열을 구해야 함
- 합 배열 S 정의
  - S[i] = A[0] + A[1] + A[2] + ... + A[i-1] + A[i]
- 합 배열은 기존의 배열을 전처리한 배열
- 합 배열을 미리 구해 놓으면 기존 범위의 합을 구하는 시간 복잡도가 O(N) 에서 O(1)로 감소
- 합 배열 S를 만드는 공식
  - S[i] = S[i-1] + A[i]
- i에서 j까지 구간 합을 구하는 공식
  - S[j] - S[i-1]
- 합 배열과 구간 합 공식을 적재 적소에 활용하면 코딩 테스트에서 시간 복잡도를 줄이는데 많은 도움이 된다.

### 구간 합 구하기
이 문제는 앞에서 배웠던 구간 합 공식과 합 배열을 사용하면 풀 수 있는 문제였다 나는 배열을 저장할 변수하나를 생성하고 그뒤에 합배열을 생성하도록 만들었는데 그럴 필요 없이 합 배열만 선언해도 문제를 풀 수 있었다. 나는 합 배열을 만들 때 5개이면 0~4 까지의 인덱스를 가지게 만들었는데 S[0]의 값으로는 아무런 값도 없게 만들고 1~5까지의 인덱스에는 배열의 합을 가지도록 만드는것이 좋은 거 같다.
[chap03_03.java]

### 구간 합 구하기 2
이 문제는 구간 합 구하기 문제에서 배웠던 구간 합을 2차원 배열로 만들어 문제를 풀어야 했다. 1차원 배열로만 사용할 줄만 알았던 구간 합을 2차원 배열로 구현하려니깐 상당히 막막했다. 하지만 순서대로 어떻게 해결할지 생각하고 그림을 그려보면서 푸는 방법을 보면서 논리적으로 어떻게 해결해나가야 하는지 배웠던 거 같다. 앞으로는 그림을 그려보면서 어떻게 해결할지 생각해 봐야겠다.
[chap03_04.java]

### 나머지 합 구하기
이 문제는 연속된 부분의 합이 M으로 떨어지는 구간의 개수를 구하는 문제였다. 나는 문제를 2차원 배열을 사용한 구간합을 이용해서 푸는 방식인줄 알았는데 여러가지 아이디어를 사용해서 문제를 풀 수 있었다. 어떻게 저런 아이디어를 생각해 내는지 신기하다. 내가 아직 문제를 많이 못 풀어봐서 그런거일수도 있지만 저렇게 생각할 수 있는게 부럽다. 나도 저렇게 생각할 수 있도록 문제를 많이 풀어봐야겠다.
[chap03_05.java]

## 투 포인터
- 2개의 알고리즘으로 시간 복잡도를 최적화

### 연속된 자연수의 합 구하기
이 문제를 풀면서 투포인터를 구현하는 방법을 배웠다 예전에 투포인터를 몰랐을 때는 이중 반복문을 사용하는 방법을 이용해서 풀었을 거 같다. 투포인터를 이용해서 시간 복잡도를 낮출 수 있는것을 배우게 되었다.
[chap03_06.java]

### 주몽의 명령
이 문제는 투포인터를 사용한 문제였는데 전에 문제는 여러개의 숫자를 더해서 하나의 값을 만들었다면 이 문제는 2개의 숫자를 이용해서 원하는 값을 얻어내는 문제였다. 투포인터를 잘 사용해 봐야겠다.
[chap03_07.java]

### 좋은 수 구하기
이 문제도 투 포인터 알고리즘을 사용하여 문제를 풀 수 있었다. 처음 문제를 읽어봤을때 이해를 못해서 어떻게 저런 값이 나오는지 알 수 없었다. 문제 이해하는 능력을 길러야 할 거 같다.
[chap03_08.java]

## 슬라이딩 윈도우
- 2개의 포인터로 범위를 지정한 다음 범위를 유지한 채로 이동하며 문제를 해결

### DNA 비밀번호
이 문제는 슬라이딩 윈도우의 개념을 이용해서 푼 문제이다. 슬라이딩 윈도우의 개념은 쉬웠지만 응용하는 방법이 어려웠던 거 같다. 문자열중 부분 문자열을 확인할때 현재 상태 배열과 비밀번호 체크 배열을 사용하는 생각을 하지 못했다. 앞으로 기억해두고 많이 써봐야겠다.
[chap03_09.java]

### 최솟값 찾기
이 문제는 슬라이딩 윈도우 알고리즘을 사용하면 문제를 풀 수 있을 거같았지만 시간 복잡도가 O(N)으로 문제를 풀어야 해서 일반적인 정렬 알고리즘을 이용해서 문제를 풀 수 없었다. 이러한 문제를 해결하기 위해 Dequeue를 사용해서 정렬하는 방법을 알아야 했다. Dequeue를 사용해 최솟값을 찾는 방법을 공부할 수 있었던 좋은 문제였다.
[chap03_10.java]

## 스택과 큐
- 배열에서 발전된 형태의 자료구조
- 구조는 비슷하지만 처리구조는 다르다.

### 스택으로 오름차순 수열 만들기
문제를 이해하는것이 상당히 어렵다. 오름차순 수열을 출력할 수 있는지 확인하라는 말을 이해못해서 문제를 풀지 못했다. 스택에 넣는 값은 오름차순 정렬이라는것을 매우 늦게 이해했다. 문제 해설을 보면서 스택의 구조를 알게되어서 좋았다.
[chap03_11.java]

### 오큰수 구하기
이 문제를 공부하면서 스택의 사용법을 알아보게 되어 좋았다. 문제를 풀 때 스택을 사용하는 법을 고려해봐야겠다.
[chap03_12.java]

### 카드 게임
큐의 특성을 알아볼 수 있는 문제였다. 큐는 선입선출 구조인걸 기억하고 LinkedList객체를 생성해서 큐를 구현할 수 있다.
[chap03_13.java]

### 절댓값 힙 구현하기
우선순위 큐를 구현하는 법을 알수 있었던 문제였다. 우선순위 큐를 사용해 객체 정렬을 할 수 있어서 좋았다. 저번에 공부했던 Collections, Comparable, Comparator 가 도움이 되었던 거 같다.
[chap03_14.java]